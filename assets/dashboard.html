<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EverMem - Memory Hub</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0d1117;
      color: #c9d1d9;
      min-height: 100vh;
    }
    #header {
      padding: 16px 24px;
      border-bottom: 1px solid #30363d;
      display: flex;
      align-items: center;
      gap: 16px;
      background: rgba(13, 17, 23, 0.95);
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 100;
      flex-wrap: wrap;
    }
    #header h1 { font-size: 18px; font-weight: 600; display: flex; align-items: center; gap: 8px; }
    #header .stats { font-size: 13px; color: #8b949e; margin-left: auto; }
    .header-controls { display: flex; align-items: center; gap: 8px; }
    .api-input {
      padding: 6px 12px;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 6px;
      color: #c9d1d9;
      font-size: 13px;
      width: 200px;
    }
    .api-input:focus { outline: none; border-color: #FFC53D; }
    .api-btn, .refresh-btn {
      padding: 6px 12px;
      background: #FFC53D;
      border: none;
      border-radius: 6px;
      color: #0d1117;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .api-btn:hover { background: #e6b038; }
    .api-btn:disabled { background: #30363d; cursor: not-allowed; }
    .refresh-btn { background: #30363d; display: none; }
    .refresh-btn:hover { background: #3d444d; }
    .refresh-btn.spinning svg { animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    #main { padding: 24px; max-width: 1200px; margin: 0 auto; }

    .loading { text-align: center; padding: 60px 20px; color: #8b949e; }
    .loading .spinner {
      width: 32px; height: 32px;
      border: 3px solid #30363d;
      border-top-color: #FFC53D;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 16px;
    }
    .error {
      background: #f8514922;
      border: 1px solid #f85149;
      border-radius: 8px;
      padding: 16px;
      color: #f85149;
      margin-bottom: 24px;
    }
    .empty-state { text-align: center; padding: 60px 20px; color: #8b949e; }
    .empty-state h3 { font-size: 18px; color: #f0f6fc; margin-bottom: 8px; }

    /* Stats Grid */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 16px;
      margin-bottom: 32px;
    }
    @media (max-width: 900px) { .stats-grid { grid-template-columns: repeat(3, 1fr); } }
    @media (max-width: 600px) { .stats-grid { grid-template-columns: 1fr; } }
    .stat-card {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 20px;
    }
    .stat-card .label { font-size: 12px; color: #8b949e; text-transform: uppercase; margin-bottom: 8px; }
    .stat-card .value { font-size: 32px; font-weight: 600; color: #f0f6fc; }
    .stat-card .sub { font-size: 12px; color: #FFC53D; margin-top: 4px; }

    /* Groups Section */
    .section-title { font-size: 16px; font-weight: 600; color: #f0f6fc; margin-bottom: 16px; }
    .groups-container { display: flex; flex-direction: column; gap: 16px; }

    /* Group Card */
    .group-card {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      overflow: hidden;
    }
    .group-header {
      padding: 16px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .group-header:hover { background: #1c2128; }
    .group-icon { font-size: 24px; }
    .group-info { flex: 1; min-width: 0; }
    .group-name { font-size: 15px; font-weight: 600; color: #f0f6fc; margin-bottom: 4px; }
    .group-path {
      font-size: 11px;
      color: #8b949e;
      font-family: monospace;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .group-stats {
      display: flex;
      gap: 16px;
      font-size: 12px;
      color: #8b949e;
    }
    .group-stats span { display: flex; align-items: center; gap: 4px; }
    .group-stats .count { color: #FFC53D; font-weight: 600; }
    .group-expand {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #8b949e;
      transition: transform 0.2s;
    }
    .group-card.expanded .group-expand { transform: rotate(180deg); }

    /* Memories List */
    .memories-container {
      display: none;
      border-top: 1px solid #30363d;
      background: #0d1117;
    }
    .group-card.expanded .memories-container { display: block; }
    .memories-loading { padding: 20px; text-align: center; color: #8b949e; }
    .memories-list { padding: 12px; }

    /* Timeline within group */
    .group-timeline { padding: 16px 20px; }
    .timeline-day-section { margin-bottom: 20px; }
    .timeline-day-section:last-child { margin-bottom: 0; }
    .timeline-day-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid #21262d;
    }
    .timeline-day-dot {
      width: 10px;
      height: 10px;
      background: #FFC53D;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .timeline-day-dot.today { box-shadow: 0 0 8px rgba(255, 197, 61, 0.6); }
    .timeline-day-date { font-size: 13px; font-weight: 600; color: #f0f6fc; }
    .timeline-day-badge {
      font-size: 10px;
      padding: 2px 8px;
      background: #FFC53D22;
      color: #FFC53D;
      border-radius: 10px;
    }
    .timeline-day-count { font-size: 11px; color: #8b949e; margin-left: auto; }
    .timeline-memories { display: flex; flex-direction: column; gap: 8px; padding-left: 22px; }

    .memory-item {
      padding: 12px 16px;
      border: 1px solid #30363d;
      border-radius: 8px;
      cursor: pointer;
      transition: border-color 0.2s, background 0.2s;
    }
    .memory-item:hover { border-color: #FFC53D; background: #161b22; }
    .memory-header { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
    .memory-emoji { font-size: 14px; }
    .memory-subject { font-size: 13px; font-weight: 500; color: #f0f6fc; flex: 1; }
    .memory-time { font-size: 11px; color: #8b949e; }
    .memory-preview { font-size: 12px; color: #8b949e; line-height: 1.5; max-height: 60px; overflow: hidden; }

    .load-more {
      padding: 12px 20px;
      text-align: center;
      border-top: 1px solid #21262d;
    }
    .load-more-btn {
      padding: 8px 16px;
      background: #21262d;
      border: 1px solid #30363d;
      border-radius: 6px;
      color: #c9d1d9;
      font-size: 13px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .load-more-btn:hover { background: #30363d; }
    .load-more-btn:disabled { opacity: 0.5; cursor: not-allowed; }

    /* Charts Row */
    .charts-row {
      display: flex;
      gap: 24px;
      margin-bottom: 32px;
    }
    @media (max-width: 900px) { .charts-row { flex-direction: column; } }

    /* Heatmap - GitHub style */
    .heatmap-section {
      flex: 2;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 20px;
      overflow-x: auto;
    }
    .heatmap-months {
      position: relative;
      font-size: 11px;
      color: #8b949e;
      margin-bottom: 8px;
      margin-left: 36px;
      height: 16px;
    }
    .heatmap-months span { position: absolute; }
    .heatmap-body { display: flex; gap: 4px; }
    .heatmap-days {
      display: flex;
      flex-direction: column;
      font-size: 11px;
      color: #8b949e;
      width: 32px;
      padding-top: 2px;
    }
    .heatmap-days span { height: 13px; line-height: 13px; }
    .heatmap-grid { display: flex; gap: 3px; }
    .heatmap-week { display: flex; flex-direction: column; gap: 3px; }
    .heatmap-cell {
      width: 13px;
      height: 13px;
      border-radius: 2px;
      background: #161b22;
      border: 1px solid #21262d;
      cursor: pointer;
      transition: transform 0.1s;
    }
    .heatmap-cell:hover { transform: scale(1.3); z-index: 10; }
    .heatmap-cell.level-1 { background: #4d3a10; border-color: #4d3a10; }
    .heatmap-cell.level-2 { background: #806200; border-color: #806200; }
    .heatmap-cell.level-3 { background: #cc9a00; border-color: #cc9a00; }
    .heatmap-cell.level-4 { background: #FFC53D; border-color: #FFC53D; }
    .heatmap-tooltip {
      position: fixed;
      background: #1c2128;
      border: 1px solid #30363d;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 12px;
      color: #c9d1d9;
      pointer-events: none;
      z-index: 1000;
      white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      display: none;
    }
    .heatmap-tooltip strong { color: #f0f6fc; }
    .heatmap-legend {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 4px;
      margin-top: 12px;
      font-size: 11px;
      color: #8b949e;
    }
    .heatmap-legend-cell { width: 12px; height: 12px; border-radius: 2px; }

    /* Growth Chart */
    .growth-section {
      flex: 1;
      min-width: 280px;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 20px;
    }
    .growth-chart {
      display: flex;
      align-items: flex-end;
      gap: 6px;
      height: 120px;
      padding: 0 4px;
    }
    .chart-bar-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100%;
    }
    .chart-bar-wrapper {
      flex: 1;
      width: 100%;
      display: flex;
      align-items: flex-end;
    }
    .chart-bar {
      width: 100%;
      background: linear-gradient(to top, #e6b038, #FFC53D);
      border-radius: 4px 4px 0 0;
      min-height: 4px;
      transition: height 0.3s ease;
      position: relative;
    }
    .chart-bar:hover { filter: brightness(1.2); }
    .chart-bar .bar-tooltip {
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      background: #0d1117;
      border: 1px solid #30363d;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 11px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      z-index: 10;
    }
    .chart-bar:hover .bar-tooltip { opacity: 1; }
    .chart-label { font-size: 10px; color: #8b949e; margin-top: 8px; }

    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, visibility 0.2s;
    }
    .modal-overlay.visible { opacity: 1; visibility: visible; }
    .modal {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      max-width: 700px;
      width: 90%;
      max-height: 80vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      transform: scale(0.95);
      transition: transform 0.2s;
    }
    .modal-overlay.visible .modal { transform: scale(1); }
    .modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid #30363d;
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }
    .modal-header-content { flex: 1; }
    .modal-title { font-size: 16px; font-weight: 600; color: #f0f6fc; margin-bottom: 4px; }
    .modal-meta { font-size: 12px; color: #8b949e; }
    .modal-close {
      background: none;
      border: none;
      color: #8b949e;
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
    }
    .modal-close:hover { color: #f0f6fc; background: #30363d; }
    .modal-body { padding: 20px; overflow-y: auto; flex: 1; }
    .modal-content { font-size: 14px; color: #c9d1d9; line-height: 1.7; white-space: pre-wrap; }
  </style>
</head>
<body>
  <div id="header">
    <h1>
      <img src="/logo.png" alt="EverMem" style="width: 24px; height: 24px; border-radius: 4px;" onerror="this.style.display='none'" />
      EverMem Memory Hub
    </h1>
    <div class="header-controls">
      <label style="font-size: 12px; color: #8b949e;">API Key:</label>
      <input type="password" id="api-key-input" class="api-input" placeholder="Enter your EverMem API key" />
      <button id="load-btn" class="api-btn" onclick="loadGroups()">Load</button>
      <button id="refresh-btn" class="refresh-btn" onclick="refreshAll()" title="Refresh">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M23 4v6h-6M1 20v-6h6"/>
          <path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/>
        </svg>
      </button>
    </div>
    <span class="stats" id="stats">Enter API key to load memories</span>
  </div>

  <div id="main">
    <div id="content">
      <div class="empty-state">
        <h3>Welcome to EverMem Memory Hub</h3>
        <p>Enter your EverMem API key above to view your memories by project.</p>
      </div>
    </div>
  </div>

  <!-- Modal -->
  <div id="modal-overlay" class="modal-overlay" onclick="closeModal(event)">
    <div class="modal" onclick="event.stopPropagation()">
      <div class="modal-header">
        <div class="modal-header-content">
          <div class="modal-title" id="modal-title"></div>
          <div class="modal-meta" id="modal-meta"></div>
        </div>
        <button class="modal-close" onclick="closeModal()">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 6L6 18M6 6l12 12"/>
          </svg>
        </button>
      </div>
      <div class="modal-body">
        <div class="modal-content" id="modal-content"></div>
      </div>
    </div>
  </div>

  <script>
    const PROXY_URL = window.location.protocol === 'file:' ? 'http://localhost:3456' : '';
    const MEMORIES_PER_PAGE = 100;

    let apiKey = '';
    let groups = [];
    let groupMemories = {}; // { groupId: { memories: [], totalCount: 0, hasMore: false, offset: 0 } }

    // Get API key from URL
    const urlParams = new URLSearchParams(window.location.search);
    const hashParams = new URLSearchParams(window.location.hash.slice(1));
    const keyFromUrl = urlParams.get('key') || urlParams.get('apiKey') || hashParams.get('key');

    // Initialize
    async function init() {
      const healthOk = await checkProxy();
      if (!healthOk) return;

      if (keyFromUrl) {
        document.getElementById('api-key-input').value = keyFromUrl;
        setTimeout(() => loadGroups(), 100);
      }
    }

    async function checkProxy() {
      try {
        const response = await fetch(`${PROXY_URL}/health`);
        if (response.ok) return true;
      } catch {}

      document.getElementById('content').innerHTML = `
        <div class="error">
          <strong>Server not running</strong>
          <p style="margin-top: 8px; color: #c9d1d9;">Start the server with:</p>
          <pre style="margin-top: 8px; padding: 12px; background: #0d1117; border-radius: 6px; font-family: monospace; color: #FFC53D;">node server/proxy.js</pre>
        </div>
      `;
      document.getElementById('load-btn').disabled = true;
      return false;
    }

    async function loadGroups() {
      apiKey = document.getElementById('api-key-input').value.trim();
      if (!apiKey) {
        alert('Please enter an API key');
        return;
      }

      const loadBtn = document.getElementById('load-btn');
      loadBtn.disabled = true;
      loadBtn.textContent = 'Loading...';

      document.getElementById('content').innerHTML = `
        <div class="loading">
          <div class="spinner"></div>
          <p>Loading your projects...</p>
        </div>
      `;

      try {
        // 1. Fetch groups from local storage
        const groupsResponse = await fetch(`${PROXY_URL}/api/groups`, {
          headers: { 'Authorization': `Bearer ${apiKey}` }
        });

        if (!groupsResponse.ok) {
          throw new Error('Failed to fetch groups');
        }

        const groupsData = await groupsResponse.json();
        groups = groupsData.groups || [];

        if (groups.length === 0) {
          document.getElementById('content').innerHTML = `
            <div class="empty-state">
              <h3>No Projects Found</h3>
              <p>No projects have been tracked yet for this API key.</p>
              <p style="margin-top: 12px; color: #8b949e;">Use Claude Code with EverMem to start saving memories.</p>
            </div>
          `;
          document.getElementById('stats').textContent = '0 projects';
          return;
        }

        // 2. For each group, fetch first page of memories
        groupMemories = {};
        let totalMemories = 0;

        await Promise.all(groups.map(async (group) => {
          const data = await fetchMemoriesForGroup(group.id, 0, MEMORIES_PER_PAGE);
          groupMemories[group.id] = {
            memories: data.memories,
            totalCount: data.totalCount,
            hasMore: data.hasMore,
            offset: data.memories.length
          };
          totalMemories += data.totalCount;
        }));

        // 3. Render dashboard
        document.getElementById('refresh-btn').style.display = 'flex';
        document.getElementById('stats').textContent = `${totalMemories} memories across ${groups.length} projects`;
        renderDashboard(totalMemories);

      } catch (error) {
        document.getElementById('content').innerHTML = `
          <div class="error">
            <strong>Error:</strong> ${error.message}
          </div>
        `;
      } finally {
        loadBtn.disabled = false;
        loadBtn.textContent = 'Load';
      }
    }

    async function fetchMemoriesForGroup(groupId, offset, limit) {
      try {
        const response = await fetch(`${PROXY_URL}/api/v0/memories`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            user_id: 'claude-code-user',
            group_id: groupId,
            memory_type: 'episodic_memory',
            limit: limit,
            offset: offset
          })
        });

        if (!response.ok) {
          throw new Error(`API error: ${response.status}`);
        }

        const data = await response.json();
        const result = data.result || {};

        return {
          memories: (result.memories || []).map(transformMemory),
          totalCount: result.total_count || 0,
          hasMore: result.has_more || false
        };
      } catch (error) {
        console.error(`Error fetching memories for ${groupId}:`, error);
        return { memories: [], totalCount: 0, hasMore: false };
      }
    }

    function transformMemory(mem) {
      const timestamp = mem.timestamp || mem.create_time || new Date().toISOString();
      const date = new Date(timestamp);

      return {
        id: mem.id || mem.message_id,
        content: mem.episode || mem.content || '',
        subject: mem.subject || '',
        groupId: mem.group_id || '',
        timestamp: timestamp,
        date: formatLocalDate(date),
        time: date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }),
        summary: mem.summary || ''
      };
    }

    function renderDashboard(totalMemories) {
      const activeGroups = groups.filter(g => groupMemories[g.id]?.totalCount > 0).length;

      // Collect all memories for charts
      const allMemories = [];
      for (const gm of Object.values(groupMemories)) {
        allMemories.push(...gm.memories);
      }
      const memoriesByDate = {};
      allMemories.forEach(mem => {
        memoriesByDate[mem.date] = (memoriesByDate[mem.date] || 0) + 1;
      });

      // Calculate active days and average
      const activeDays = Object.keys(memoriesByDate).length;
      const avgPerDay = activeDays > 0 ? (totalMemories / activeDays).toFixed(1) : 0;

      let html = `
        <div class="stats-grid">
          <div class="stat-card">
            <div class="label">Total Memories</div>
            <div class="value">${totalMemories}</div>
            <div class="sub">Across all projects</div>
          </div>
          <div class="stat-card">
            <div class="label">Projects</div>
            <div class="value">${groups.length}</div>
            <div class="sub">${activeGroups} with memories</div>
          </div>
          <div class="stat-card">
            <div class="label">Active Days</div>
            <div class="value">${activeDays}</div>
            <div class="sub">Days with memories</div>
          </div>
          <div class="stat-card">
            <div class="label">Avg / Day</div>
            <div class="value">${avgPerDay}</div>
            <div class="sub">Memories per active day</div>
          </div>
          <div class="stat-card">
            <div class="label">Avg / Project</div>
            <div class="value">${activeGroups > 0 ? Math.round(totalMemories / activeGroups) : 0}</div>
            <div class="sub">Memories per project</div>
          </div>
        </div>

        <div class="charts-row">
          <div class="heatmap-section">
            <div class="section-title">Memory Activity (6 months)</div>
            <div class="heatmap-months" id="heatmap-months"></div>
            <div class="heatmap-body">
              <div class="heatmap-days">
                <span></span><span>Mon</span><span></span><span>Wed</span><span></span><span>Fri</span><span></span>
              </div>
              <div class="heatmap-grid" id="heatmap"></div>
            </div>
            <div class="heatmap-legend">
              <span>Less</span>
              <div class="heatmap-legend-cell" style="background: #161b22; border: 1px solid #21262d;"></div>
              <div class="heatmap-legend-cell" style="background: #4d3a10;"></div>
              <div class="heatmap-legend-cell" style="background: #806200;"></div>
              <div class="heatmap-legend-cell" style="background: #cc9a00;"></div>
              <div class="heatmap-legend-cell" style="background: #FFC53D;"></div>
              <span>More</span>
            </div>
          </div>
          <div class="growth-section">
            <div class="section-title">Last 7 Days</div>
            <div class="growth-chart" id="growth-chart"></div>
          </div>
        </div>
        <div class="heatmap-tooltip" id="heatmap-tooltip"></div>

        <div class="section-title">Your Projects</div>
        <div class="groups-container">
      `;

      window._memoriesByDate = memoriesByDate;

      // Sort groups by memory count (descending)
      const sortedGroups = [...groups].sort((a, b) => {
        const countA = groupMemories[a.id]?.totalCount || 0;
        const countB = groupMemories[b.id]?.totalCount || 0;
        return countB - countA;
      });

      for (const group of sortedGroups) {
        const gm = groupMemories[group.id] || { memories: [], totalCount: 0, hasMore: false };
        html += renderGroupCard(group, gm);
      }

      html += '</div>';
      document.getElementById('content').innerHTML = html;

      // Build charts after rendering
      buildHeatmap(window._memoriesByDate);
      buildGrowthChart(window._memoriesByDate);
    }

    function buildHeatmap(memoriesByDate) {
      const heatmapContainer = document.getElementById('heatmap');
      const monthsContainer = document.getElementById('heatmap-months');
      if (!heatmapContainer) return;

      const today = new Date();
      const startDate = new Date(today);
      startDate.setDate(startDate.getDate() - 182);
      while (startDate.getDay() !== 0) {
        startDate.setDate(startDate.getDate() - 1);
      }

      const weeks = [];
      let currentWeek = [];
      const months = new Map();
      let currentDate = new Date(startDate);

      while (currentDate <= today) {
        const dateStr = formatLocalDate(currentDate);
        const monthKey = currentDate.toLocaleDateString('en-US', { month: 'short' });

        if (!months.has(monthKey)) {
          months.set(monthKey, weeks.length);
        }

        currentWeek.push({
          date: dateStr,
          count: memoriesByDate[dateStr] || 0,
          dayOfWeek: currentDate.getDay()
        });

        if (currentDate.getDay() === 6) {
          weeks.push(currentWeek);
          currentWeek = [];
        }

        currentDate.setDate(currentDate.getDate() + 1);
      }

      if (currentWeek.length > 0) {
        weeks.push(currentWeek);
      }

      // Render month labels
      monthsContainer.innerHTML = '';
      const weekWidth = 16;
      months.forEach((weekIndex, monthName) => {
        const span = document.createElement('span');
        span.textContent = monthName;
        span.style.left = `${weekIndex * weekWidth}px`;
        monthsContainer.appendChild(span);
      });

      // Calculate thresholds
      const maxCount = Math.max(...Object.values(memoriesByDate), 1);
      const q1 = Math.max(1, Math.ceil(maxCount * 0.25));
      const q2 = Math.max(2, Math.ceil(maxCount * 0.5));
      const q3 = Math.max(3, Math.ceil(maxCount * 0.75));

      // Render weeks
      heatmapContainer.innerHTML = '';
      weeks.forEach((week, weekIndex) => {
        const weekDiv = document.createElement('div');
        weekDiv.className = 'heatmap-week';

        if (weekIndex === 0 && week[0].dayOfWeek !== 0) {
          for (let i = 0; i < week[0].dayOfWeek; i++) {
            const emptyCell = document.createElement('div');
            emptyCell.className = 'heatmap-cell';
            emptyCell.style.visibility = 'hidden';
            weekDiv.appendChild(emptyCell);
          }
        }

        week.forEach(day => {
          const cell = document.createElement('div');
          cell.className = 'heatmap-cell';
          cell.dataset.date = day.date;
          cell.dataset.count = day.count;

          if (day.count >= q3) cell.classList.add('level-4');
          else if (day.count >= q2) cell.classList.add('level-3');
          else if (day.count >= q1) cell.classList.add('level-2');
          else if (day.count >= 1) cell.classList.add('level-1');

          cell.addEventListener('mouseenter', showHeatmapTooltip);
          cell.addEventListener('mouseleave', hideHeatmapTooltip);
          weekDiv.appendChild(cell);
        });

        if (weekIndex === weeks.length - 1 && week[week.length - 1].dayOfWeek !== 6) {
          for (let i = week[week.length - 1].dayOfWeek + 1; i <= 6; i++) {
            const emptyCell = document.createElement('div');
            emptyCell.className = 'heatmap-cell';
            emptyCell.style.visibility = 'hidden';
            weekDiv.appendChild(emptyCell);
          }
        }

        heatmapContainer.appendChild(weekDiv);
      });
    }

    function showHeatmapTooltip(e) {
      const tooltip = document.getElementById('heatmap-tooltip');
      const cell = e.target;
      const date = cell.dataset.date;
      const count = parseInt(cell.dataset.count);

      const dateObj = new Date(date + 'T12:00:00');
      const formattedDate = dateObj.toLocaleDateString('en-US', {
        weekday: 'short', month: 'short', day: 'numeric', year: 'numeric'
      });

      tooltip.innerHTML = `<strong>${count} ${count === 1 ? 'memory' : 'memories'}</strong> on ${formattedDate}`;
      tooltip.style.display = 'block';

      const rect = cell.getBoundingClientRect();
      tooltip.style.left = `${rect.left + rect.width / 2}px`;
      tooltip.style.top = `${rect.top - 40}px`;
      tooltip.style.transform = 'translateX(-50%)';
    }

    function hideHeatmapTooltip() {
      document.getElementById('heatmap-tooltip').style.display = 'none';
    }

    function buildGrowthChart(memoriesByDate) {
      const chartContainer = document.getElementById('growth-chart');
      if (!chartContainer) return;

      const today = new Date();
      const dailyData = [];

      for (let i = 6; i >= 0; i--) {
        const date = new Date(today);
        date.setDate(date.getDate() - i);
        const dateStr = formatLocalDate(date);
        const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
        dailyData.push({ date: dayName, count: memoriesByDate[dateStr] || 0 });
      }

      const maxCount = Math.max(...dailyData.map(d => d.count), 1);

      chartContainer.innerHTML = '';
      dailyData.forEach(day => {
        const barContainer = document.createElement('div');
        barContainer.className = 'chart-bar-container';

        const barWrapper = document.createElement('div');
        barWrapper.className = 'chart-bar-wrapper';

        const bar = document.createElement('div');
        bar.className = 'chart-bar';
        bar.style.height = day.count > 0 ? `${(day.count / maxCount) * 100}%` : '4px';
        bar.style.opacity = day.count > 0 ? '1' : '0.2';

        const barTooltip = document.createElement('div');
        barTooltip.className = 'bar-tooltip';
        barTooltip.textContent = `${day.count} memories`;
        bar.appendChild(barTooltip);

        const label = document.createElement('div');
        label.className = 'chart-label';
        label.textContent = day.date;

        barWrapper.appendChild(bar);
        barContainer.appendChild(barWrapper);
        barContainer.appendChild(label);
        chartContainer.appendChild(barContainer);
      });
    }

    function renderGroupCard(group, gm) {
      const memCount = gm.totalCount;
      const hasMemories = memCount > 0;

      return `
        <div class="group-card" id="group-${encodeId(group.id)}" data-group-id="${escapeHtml(group.id)}">
          <div class="group-header" onclick="toggleGroup('${escapeHtml(group.id)}')">
            <span class="group-icon">üìÅ</span>
            <div class="group-info">
              <div class="group-name">${escapeHtml(group.name)}</div>
              <div class="group-path">${escapeHtml(group.path)}</div>
            </div>
            <div class="group-stats">
              <span><span class="count">${memCount}</span> memories</span>
              <span>${group.sessionCount} sessions</span>
            </div>
            ${hasMemories ? `
              <div class="group-expand">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M6 9l6 6 6-6"/>
                </svg>
              </div>
            ` : ''}
          </div>
          ${hasMemories ? `
            <div class="memories-container" id="memories-${encodeId(group.id)}">
              ${renderMemoriesList(group.id, gm)}
            </div>
          ` : ''}
        </div>
      `;
    }

    function renderMemoriesList(groupId, gm) {
      if (gm.memories.length === 0) {
        return '<div class="memories-loading">No memories yet</div>';
      }

      // Group memories by date
      const byDate = {};
      gm.memories.forEach(mem => {
        if (!byDate[mem.date]) byDate[mem.date] = [];
        byDate[mem.date].push(mem);
      });

      // Sort dates descending (most recent first)
      const sortedDates = Object.keys(byDate).sort().reverse();
      const todayStr = formatLocalDate(new Date());

      let html = '<div class="group-timeline">';

      for (const date of sortedDates) {
        const dayMemories = byDate[date].sort((a, b) =>
          new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
        );
        const isToday = date === todayStr;

        const dateDisplay = new Date(date + 'T12:00:00').toLocaleDateString('en-US', {
          weekday: 'short', month: 'short', day: 'numeric'
        });

        html += `
          <div class="timeline-day-section">
            <div class="timeline-day-header">
              <div class="timeline-day-dot${isToday ? ' today' : ''}"></div>
              <span class="timeline-day-date">${dateDisplay}</span>
              ${isToday ? '<span class="timeline-day-badge">Today</span>' : ''}
              <span class="timeline-day-count">${dayMemories.length} ${dayMemories.length === 1 ? 'memory' : 'memories'}</span>
            </div>
            <div class="timeline-memories">
        `;

        for (const mem of dayMemories) {
          const emoji = getEmojiForContent(mem.subject || mem.content);
          const displaySubject = mem.subject || (mem.content.length > 50 ? mem.content.slice(0, 50) + '...' : mem.content);
          const preview = mem.content.length > 120 ? mem.content.slice(0, 120) + '...' : mem.content;

          html += `
            <div class="memory-item" onclick='openModal(${JSON.stringify(mem).replace(/'/g, "&#39;")})'>
              <div class="memory-header">
                <span class="memory-emoji">${emoji}</span>
                <span class="memory-subject">${escapeHtml(displaySubject)}</span>
                <span class="memory-time">${mem.time}</span>
              </div>
              <div class="memory-preview">${escapeHtml(preview)}</div>
            </div>
          `;
        }

        html += '</div></div>';
      }

      html += '</div>';

      // Load more button
      if (gm.hasMore) {
        html += `
          <div class="load-more">
            <button class="load-more-btn" onclick="loadMoreMemories('${escapeHtml(groupId)}')">
              Load more (${gm.totalCount - gm.memories.length} remaining)
            </button>
          </div>
        `;
      }

      return html;
    }

    function toggleGroup(groupId) {
      const card = document.getElementById(`group-${encodeId(groupId)}`);
      if (!card) return;

      const gm = groupMemories[groupId];
      if (!gm || gm.totalCount === 0) return;

      card.classList.toggle('expanded');
    }

    async function loadMoreMemories(groupId) {
      const gm = groupMemories[groupId];
      if (!gm || !gm.hasMore) return;

      const btn = event.target;
      btn.disabled = true;
      btn.textContent = 'Loading...';

      try {
        const data = await fetchMemoriesForGroup(groupId, gm.offset, MEMORIES_PER_PAGE);

        gm.memories = [...gm.memories, ...data.memories];
        gm.hasMore = data.hasMore;
        gm.offset += data.memories.length;

        // Re-render just this group's memories
        const container = document.getElementById(`memories-${encodeId(groupId)}`);
        if (container) {
          container.innerHTML = renderMemoriesList(groupId, gm);
        }
      } catch (error) {
        alert('Failed to load more memories: ' + error.message);
        btn.disabled = false;
        btn.textContent = 'Load more';
      }
    }

    async function refreshAll() {
      const btn = document.getElementById('refresh-btn');
      btn.classList.add('spinning');
      btn.disabled = true;
      await loadGroups();
      btn.classList.remove('spinning');
      btn.disabled = false;
    }

    function openModal(memory) {
      const dateStr = new Date(memory.timestamp).toLocaleDateString('en-US', {
        weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit'
      });

      document.getElementById('modal-title').textContent = memory.subject || 'Memory';
      document.getElementById('modal-meta').textContent = dateStr;
      document.getElementById('modal-content').textContent = memory.content;

      document.getElementById('modal-overlay').classList.add('visible');
      document.body.style.overflow = 'hidden';
    }

    function closeModal(event) {
      if (event && event.target !== event.currentTarget) return;
      document.getElementById('modal-overlay').classList.remove('visible');
      document.body.style.overflow = '';
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closeModal();
    });

    // Helpers
    function encodeId(str) {
      return btoa(str).replace(/[+/=]/g, c => ({ '+': '-', '/': '_', '=': '' }[c]));
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function formatLocalDate(date) {
      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
    }

    // Emoji mapping (simplified)
    const emojiKeywords = [
      ['debug', 'üêõ'], ['bug', 'üêõ'], ['fix', 'üîß'], ['error', '‚ùå'],
      ['test', 'üß™'], ['add', '‚ûï'], ['create', '‚ú®'], ['new', 'üÜï'],
      ['remove', 'üóëÔ∏è'], ['delete', 'üóëÔ∏è'], ['update', '‚úèÔ∏è'], ['change', 'üìù'],
      ['refactor', '‚ôªÔ∏è'], ['optimize', '‚ö°'], ['deploy', 'üöÄ'], ['release', 'üì¶'],
      ['api', 'üîå'], ['database', 'üóÑÔ∏è'], ['auth', 'üîê'], ['security', 'üõ°Ô∏è'],
      ['ui', 'üé®'], ['style', 'üíÖ'], ['docs', 'üìñ'], ['config', '‚öôÔ∏è'],
      ['build', 'üèóÔ∏è'], ['merge', 'üîÄ'], ['review', 'üëÄ'], ['commit', 'üìù'],
    ];

    function getEmojiForContent(text) {
      if (!text) return 'üí≠';
      const lower = text.toLowerCase();
      for (const [keyword, emoji] of emojiKeywords) {
        if (lower.includes(keyword)) return emoji;
      }
      return 'üí≠';
    }

    // Start
    init();
  </script>
</body>
</html>